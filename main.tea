/**
 * This is for OpenApi SDK
 */

import Util;
import Credential;
import OpenApiUtil;
import SPI;
import XML;

type @endpoint = string
type @regionId = string
type @protocol = string
type @method = string
type @userAgent = string
type @endpointRule = string
type @endpointMap = map[string]string
type @suffix = string
type @readTimeout = integer
type @connectTimeout = integer
type @httpProxy = string
type @httpsProxy = string
type @socks5Proxy = string
type @socks5NetWork = string
type @noProxy = string
type @network = string
type @productId = string
type @maxIdleConns = integer
type @endpointType = string
type @openPlatformEndpoint = string
type @credential = Credential
type @signatureVersion = string
type @signatureAlgorithm = string
type @headers = map[string]string
type @spi = SPI
type @globalParameters = GlobalParameters
type @key = string
type @cert = string
type @ca = string
type @disableHttp2 = boolean
type @tlsMinVersion = string
type @attributeMap = SPI.AttributeMap
type @enableUsageDataCollection = boolean

model GlobalParameters {
  headers?: map[string]string,
  queries?: map[string]string,
}
/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',example='a.txt',default=''),
  bearerToken?: string(description='bearer token',example='the-bearer-token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  method?: string(description='http method',example='GET',default=''),
  regionId?: string(description='region id',example='cn-hangzhou',default=''),
  readTimeout?: integer(description='read timeout',example='10',default=''),
  connectTimeout?: integer(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  credential?: Credential(description='credential',example='',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: integer(description='max idle conns',example='3',default=''),
  network?: string(description='network for endpoint',example='public',default=''),
  userAgent?: string(description='user agent',example='Alibabacloud/1',default=''),
  suffix?: string(description='suffix for endpoint',example='aliyun',default=''),
  socks5Proxy?: string(description='socks5 proxy',default=''),
  socks5NetWork?: string(description='socks5 network',example='TCP',default=''),
  endpointType?: string(description='endpoint type',example='internal',default=''),
  openPlatformEndpoint?: string(description='OpenPlatform endpoint',example='openplatform.aliyuncs.com',default=''),
  type?: string(description='credential type',example='access_key',default='',deprecated=true),
  signatureVersion?: string(description='Signature Version',example='v1',default=''),
  signatureAlgorithm?: string(description='Signature Algorithm',example='ACS3-HMAC-SHA256',default=''),
  globalParameters?: GlobalParameters(description='Global Parameters'),
  key?: string(description='privite key for client certificate', example='MIIEvQ',default=''),
  cert?: string(description='client certificate', example='-----BEGIN CERTIFICATE-----\nxxx-----END CERTIFICATE-----',default=''),
  ca?: string(description='server certificate', example='-----BEGIN CERTIFICATE-----\nxxx-----END CERTIFICATE-----',default=''),
  disableHttp2?: boolean(description='disable HTTP/2', example='false'),
  tlsMinVersion?: string(description='TLS Minimum Version', example='TLSv1, TLSv1.1, TLSv1.2, TLSv1.3',default=''),
  enableUsageDataCollection?: boolean(description='Enable usage data collection. If true, it means that you are aware of and confirm your authorization to Alibaba Cloud to collect your machine information. Currently, only the hostname is collected to obtain your call information.', default=false),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  if(!Util.empty(config.accessKeyId) && !Util.empty(config.accessKeySecret)){
    if (!Util.empty(config.securityToken)) {
      config.type = 'sts';
    } else {
      config.type = 'access_key';
    }
    var credentialConfig = new Credential.Config{
      accessKeyId = config.accessKeyId,
      type = config.type,
      accessKeySecret = config.accessKeySecret
    };
    credentialConfig.securityToken = config.securityToken;
    @credential = new Credential(credentialConfig);
  } else if (!Util.empty(config.bearerToken)) {
    var cc = new Credential.Config{
      type = 'bearer',
      bearerToken = config.bearerToken
    };
    @credential = new Credential(cc);
  } else if(!Util.isUnset(config.credential)) {
    @credential = config.credential;
  }
  @endpoint = config.endpoint;
  @endpointType = config.endpointType;
  @network = config.network;
  @suffix = config.suffix;
  @protocol = config.protocol;
  @method = config.method;
  @regionId = config.regionId;
  @userAgent = config.userAgent;
  @readTimeout = config.readTimeout;
  @connectTimeout = config.connectTimeout;
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = config.maxIdleConns;
  @signatureVersion = config.signatureVersion;
  @signatureAlgorithm = config.signatureAlgorithm;
  @globalParameters = config.globalParameters;
  @key = config.key;
  @cert = config.cert;
  @ca = config.ca;
  @disableHttp2 = config.disableHttp2;
  @tlsMinVersion = config.tlsMinVersion;
  @enableUsageDataCollection = config.enableUsageDataCollection;
}

model OpenApiRequest {
  headers?: map[string]string,
  query?: map[string]string,
  body?: any,
  stream?: readable,
  hostMap?: map[string]string,
  endpointOverride?: string,
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRPCRequest(action: string, version: string, protocol: string, method: string, authType: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = '/';
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.query = {
    Action = action,
    Format = 'json',
    Version = version,
    Timestamp = OpenApiUtil.getTimestamp(),
    SignatureNonce = Util.getNonce(),
    ...globalQueries,
    ...extendsQueries,
    ...request.query
  };

  var headers = getRpcHeaders();
  if(Util.isUnset(headers)){
    // endpoint is setted in product client
    __request.headers = {
      host = @endpoint,
      x-acs-version = version,
      x-acs-action = action,
      user-agent = getUserAgent(),
      ...globalHeaders,
      ...extendsHeaders,
      ...request.headers
    };
  } else {
    __request.headers = {
      host = @endpoint,
      x-acs-version = version,
      x-acs-action = action,
      user-agent = getUserAgent(),
      ...globalHeaders,
      ...extendsHeaders,
      ...request.headers,
      ...headers
    };
  }

  if (!Util.isUnset(@enableUsageDataCollection) && @enableUsageDataCollection) {
    var hostname = Util.getHostName();
    if (Util.isUnset(hostname)) {
      hostname = 'unknown';
    }
    __request.headers.x-sdk-hostname = hostname;
  }

  if (!Util.isUnset(request.body)) {
    var m = Util.assertAsMap(request.body);
    var tmp = Util.anyifyMapValue(OpenApiUtil.query(m));
    __request.body = Util.toFormString(tmp);
    __request.headers.content-type = 'application/x-www-form-urlencoded';
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    if (Util.isUnset(@credential)) {
      throw {
        code = `InvalidCredentials`,
        message = `Please set up the credentials correctly. If you are setting them through environment variables, please ensure that ALIBABA_CLOUD_ACCESS_KEY_ID and ALIBABA_CLOUD_ACCESS_KEY_SECRET are set correctly. See https://help.aliyun.com/zh/sdk/developer-reference/configure-the-alibaba-cloud-accesskey-environment-variable-on-linux-macos-and-windows-systems for more details.`
      }
    }
    var credentialModel = @credential.getCredential();
    if (!Util.empty(credentialModel.providerName)) {
      __request.headers.x-acs-credentials-provider = credentialModel.providerName;
    }
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.query.BearerToken = bearerToken;
      __request.query.SignatureType = 'BEARERTOKEN';
    } else if (Util.equalString(credentialType, 'id_token')) {
      var idToken = credentialModel.securityToken;
      __request.headers.x-acs-zero-trust-idtoken = idToken;
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.query.SecurityToken = securityToken;
      }
      __request.query.SignatureMethod = 'HMAC-SHA1';
      __request.query.SignatureVersion = '1.0';
      __request.query.AccessKeyId = accessKeyId;
      var t : map[string]any = null;
      if (!Util.isUnset(request.body)) {
        t = Util.assertAsMap(request.body);
      }
      var signedParam = {
        ...__request.query,
        ...OpenApiUtil.query(t)
      };
      __request.query.Signature = OpenApiUtil.getRPCSignature(signedParam, __request.method, accessKeySecret);
    }
  }
} returns {
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    var requestId = defaultAny(err.RequestId, err.requestId);
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${requestId}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  tlsMinVersion = @tlsMinVersion
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param pathname pathname of every api
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doROARequest(action: string, version: string, protocol: string, method: string, authType: string, pathname: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.headers = {
    date = Util.getDateUTCString(),
    host = @endpoint,
    accept = 'application/json',
    x-acs-signature-nonce = Util.getNonce(),
    x-acs-signature-method = 'HMAC-SHA1',
    x-acs-signature-version = '1.0',
    x-acs-version = version,
    x-acs-action = action,
    user-agent = Util.getUserAgent(@userAgent),
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers
  };

  if (!Util.isUnset(@enableUsageDataCollection) && @enableUsageDataCollection) {
    var hostname = Util.getHostName();
    if (Util.isUnset(hostname)) {
      hostname = 'unknown';
    }
    __request.headers.x-sdk-hostname = hostname;
  }

  if (!Util.isUnset(request.body)) {
    __request.body = Util.toJSONString(request.body);
    __request.headers.content-type = 'application/json; charset=utf-8';
  }

  __request.query = {
    ...globalQueries,
    ...extendsQueries,
  };
  if (!Util.isUnset(request.query)) {
    __request.query = {
      ...__request.query,
      ...request.query
    };
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    if (Util.isUnset(@credential)) {
      throw {
        code = `InvalidCredentials`,
        message = `Please set up the credentials correctly. If you are setting them through environment variables, please ensure that ALIBABA_CLOUD_ACCESS_KEY_ID and ALIBABA_CLOUD_ACCESS_KEY_SECRET are set correctly. See https://help.aliyun.com/zh/sdk/developer-reference/configure-the-alibaba-cloud-accesskey-environment-variable-on-linux-macos-and-windows-systems for more details.`
      }
    }
    var credentialModel = @credential.getCredential();
    if (!Util.empty(credentialModel.providerName)) {
      __request.headers.x-acs-credentials-provider = credentialModel.providerName;
    }
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      __request.headers.x-acs-signature-type = 'BEARERTOKEN';
    } else if (Util.equalString(credentialType, 'id_token')) {
      var idToken = credentialModel.securityToken;
      __request.headers.x-acs-zero-trust-idtoken = idToken;
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }

      var stringToSign = OpenApiUtil.getStringToSign(__request);
      __request.headers.authorization = `acs ${accessKeyId}:${OpenApiUtil.getROASignature(stringToSign, accessKeySecret)}`;
    }
  }
} returns {
  if (Util.equalNumber(__response.statusCode, 204)) {
    return {
      headers = __response.headers
    };
  }

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    var requestId = defaultAny(err.RequestId, err.requestId);
    requestId = defaultAny(requestId, err.requestid);
    err.statusCode = __response.statusCode;
     throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${requestId}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  tlsMinVersion = @tlsMinVersion
}

/**
 * Encapsulate the request and invoke the network with form body
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param pathname pathname of every api
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doROARequestWithForm(action: string, version: string, protocol: string, method: string,  authType: string, pathname: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.headers = {
    date = Util.getDateUTCString(),
    host = @endpoint,
    accept = 'application/json',
    x-acs-signature-nonce = Util.getNonce(),
    x-acs-signature-method = 'HMAC-SHA1',
    x-acs-signature-version = '1.0',
    x-acs-version = version,
    x-acs-action = action,
    user-agent = Util.getUserAgent(@userAgent),
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers
  };

  if (!Util.isUnset(@enableUsageDataCollection) && @enableUsageDataCollection) {
    var hostname = Util.getHostName();
    if (Util.isUnset(hostname)) {
      hostname = 'unknown';
    }
    __request.headers.x-sdk-hostname = hostname;
  }

  if (!Util.isUnset(request.body)) {
    var m = Util.assertAsMap(request.body);
    __request.body = OpenApiUtil.toForm(m);
    __request.headers.content-type = 'application/x-www-form-urlencoded';
  }


  __request.query = {
    ...globalQueries,
    ...extendsQueries,
  };
  if (!Util.isUnset(request.query)) {
    __request.query = {
      ...__request.query,
      ...request.query
    };
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    if (Util.isUnset(@credential)) {
      throw {
        code = `InvalidCredentials`,
        message = `Please set up the credentials correctly. If you are setting them through environment variables, please ensure that ALIBABA_CLOUD_ACCESS_KEY_ID and ALIBABA_CLOUD_ACCESS_KEY_SECRET are set correctly. See https://help.aliyun.com/zh/sdk/developer-reference/configure-the-alibaba-cloud-accesskey-environment-variable-on-linux-macos-and-windows-systems for more details.`
      }
    }
    var credentialModel = @credential.getCredential();
    if (!Util.empty(credentialModel.providerName)) {
      __request.headers.x-acs-credentials-provider = credentialModel.providerName;
    }
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      __request.headers.x-acs-signature-type = 'BEARERTOKEN';
    } else if (Util.equalString(credentialType, 'id_token')) {
      var idToken = credentialModel.securityToken;
      __request.headers.x-acs-zero-trust-idtoken = idToken;
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }

      var stringToSign = OpenApiUtil.getStringToSign(__request);
      __request.headers.authorization = `acs ${accessKeyId}:${OpenApiUtil.getROASignature(stringToSign, accessKeySecret)}`;
    }
  }
} returns {
  if (Util.equalNumber(__response.statusCode, 204)) {
    return {
      headers = __response.headers
    };
  }

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${defaultAny(err.RequestId, err.requestId)}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  tlsMinVersion = @tlsMinVersion
}

model Params = {
  action: string,
  version: string,
  protocol: string,
  pathname: string,
  method: string,
  authType: string,
  bodyType: string,
  reqBodyType: string,
  style?: string
}

async function callApi(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  if (Util.isUnset(params)) {
    throw {
      code = 'ParameterMissing',
      message = '\'params\' can not be unset'
    };
  }
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    if (Util.isUnset(@signatureAlgorithm) || !Util.equalString(@signatureAlgorithm, 'v2')) {
      return doRequest(params, request, runtime);
    } else if (Util.equalString(params.style, 'ROA') && Util.equalString(params.reqBodyType, 'json')) {
      return doROARequest(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);
    } else if (Util.equalString(params.style, 'ROA')) {
      return doROARequestWithForm(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);
    } else {
      return doRPCRequest(params.action, params.version, params.protocol, params.method, params.authType, params.bodyType, request, runtime);
    }
  } else {
    return execute(params, request, runtime);
  }
}
/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, params.protocol);
  __request.method = params.method;
  __request.pathname = params.pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.query = {
    ...globalQueries,
    ...extendsQueries,
    ...request.query,
  };

  // endpoint is setted in product client
  __request.headers = {
    host = @endpoint,
    x-acs-version = params.version,
    x-acs-action = params.action,
    user-agent = getUserAgent(),
    x-acs-date= OpenApiUtil.getTimestamp(),
    x-acs-signature-nonce = Util.getNonce(),
    accept = 'application/json',
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers,
  };
  if (Util.equalString(params.style, 'RPC')) {
    var headers = getRpcHeaders();
    if (!Util.isUnset(headers)) {
      __request.headers = {
        ...__request.headers,
        ...headers
      };
    }
  }

  if (!Util.isUnset(@enableUsageDataCollection) && @enableUsageDataCollection) {
    var hostname = Util.getHostName();
    if (Util.isUnset(hostname)) {
      hostname = 'unknown';
    }
    __request.headers.x-sdk-hostname = hostname;
  }

  var signatureAlgorithm = Util.defaultString(@signatureAlgorithm, 'ACS3-HMAC-SHA256');
  var hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(''), signatureAlgorithm));

  if (!Util.isUnset(request.stream)) {
    var tmp = Util.readAsBytes(request.stream);
    hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(tmp, signatureAlgorithm));
    __request.body = tmp;
    __request.headers.content-type = 'application/octet-stream';
  } else {
    if (!Util.isUnset(request.body)) {
      if (Util.equalString(params.reqBodyType, 'byte')) {
        var byteObj = Util.assertAsBytes(request.body);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(byteObj, signatureAlgorithm));
        __request.body = byteObj;
      } else if (Util.equalString(params.reqBodyType, 'json')) {
        var jsonObj = Util.toJSONString(request.body);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(jsonObj), signatureAlgorithm));
        __request.body = jsonObj;
        __request.headers.content-type = 'application/json; charset=utf-8';
      } else {
        var m = Util.assertAsMap(request.body);
        var formObj = OpenApiUtil.toForm(m);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(formObj), signatureAlgorithm));
        __request.body = formObj;
        __request.headers.content-type = 'application/x-www-form-urlencoded';
      }
    }
  }

  __request.headers.x-acs-content-sha256 = hashedRequestPayload;

  if (!Util.equalString(params.authType, 'Anonymous')) {
    if (Util.isUnset(@credential)) {
      throw {
        code = `InvalidCredentials`,
        message = `Please set up the credentials correctly. If you are setting them through environment variables, please ensure that ALIBABA_CLOUD_ACCESS_KEY_ID and ALIBABA_CLOUD_ACCESS_KEY_SECRET are set correctly. See https://help.aliyun.com/zh/sdk/developer-reference/configure-the-alibaba-cloud-accesskey-environment-variable-on-linux-macos-and-windows-systems for more details.`
      }
    }
    var credentialModel = @credential.getCredential();
    if (!Util.empty(credentialModel.providerName)) {
      __request.headers.x-acs-credentials-provider = credentialModel.providerName;
    }
    var authType = credentialModel.type;
    if (Util.equalString(authType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      if (Util.equalString(params.style, 'RPC')) {
        __request.query.SignatureType = 'BEARERTOKEN';
      } else {
        __request.headers.x-acs-signature-type = 'BEARERTOKEN';
      }
    } else if (Util.equalString(authType, 'id_token')) {
      var idToken = credentialModel.securityToken;
      __request.headers.x-acs-zero-trust-idtoken = idToken;
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;

      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }
      __request.headers.Authorization = OpenApiUtil.getAuthorization(__request, signatureAlgorithm, hashedRequestPayload, accessKeyId, accessKeySecret);
    }
  }
} returns {
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var err : map[string]any = {};
    if (!Util.isUnset(__response.headers.content-type) && Util.equalString(__response.headers.content-type, 'text/xml;charset=utf-8')) {
      var _str = Util.readAsString(__response.body);
      var respMap = XML.parseXml(_str, null);
      err = Util.assertAsMap(respMap.Error);
    } else {
      var _res = Util.readAsJSON(__response.body);
      err = Util.assertAsMap(_res);
    }
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${defaultAny(err.RequestId, err.requestId)}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(params.bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(params.bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    var anything = Util.readAsString(__response.body);
    return {
      body = anything,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  tlsMinVersion = @tlsMinVersion
}


/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api execute(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  // spi = new Gateway();//Gateway implements SPI，这一步在产品 SDK 中实例化
  var headers = getRpcHeaders();
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  var requestContext = new SPI.InterceptorContext.request{
    headers = {
      ...globalHeaders,
      ...extendsHeaders,
      ...request.headers,
      ...headers
    },
    query = {
      ...globalQueries,
      ...extendsQueries,
      ...request.query,
    },
    body = request.body,
    stream = request.stream,
    hostMap = request.hostMap,
    pathname = params.pathname,
    productId = @productId,
    action = params.action,
    version = params.version,
    protocol = Util.defaultString(@protocol, params.protocol),
    method = Util.defaultString(@method, params.method),
    authType = params.authType,
    bodyType = params.bodyType,
    reqBodyType = params.reqBodyType,
    style = params.style,
    credential = @credential,
    signatureVersion = @signatureVersion,
    signatureAlgorithm = @signatureAlgorithm,
    userAgent = getUserAgent()
  };
  var configurationContext = new SPI.InterceptorContext.configuration{
    regionId = @regionId,
    endpoint = Util.defaultString(request.endpointOverride, @endpoint),
    endpointRule = @endpointRule,
    endpointMap = @endpointMap,
    endpointType = @endpointType,
    network = @network,
    suffix = @suffix
  };
  var interceptorContext =  new SPI.InterceptorContext{};
  interceptorContext.request = requestContext;
  interceptorContext.configuration = configurationContext;
  var attributeMap = new SPI.AttributeMap{};
  if (!Util.isUnset(@attributeMap)) {
    attributeMap = @attributeMap;
  }
  // 1. spi.modifyConfiguration(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyConfiguration(interceptorContext, attributeMap);

  // 2. spi.modifyRequest(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyRequest(interceptorContext, attributeMap);

  __request.protocol = interceptorContext.request.protocol;
  __request.method = interceptorContext.request.method;
  __request.pathname = interceptorContext.request.pathname;
  __request.query = interceptorContext.request.query;
  __request.body = interceptorContext.request.stream;
  __request.headers = interceptorContext.request.headers;
  
} returns {
  var responseContext = new SPI.InterceptorContext.response{
    statusCode = __response.statusCode,
    headers = __response.headers,
    body = __response.body
  };
  interceptorContext.response = responseContext;

  // 3. spi.modifyResponse(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyResponse(interceptorContext, attributeMap);

  return {
    headers = interceptorContext.response.headers,
    statusCode = interceptorContext.response.statusCode,
    body = interceptorContext.response.deserializedBody
  };

} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  disableHttp2 = defaultAny(@disableHttp2, false),
  tlsMinVersion = @tlsMinVersion
}

/**
 * Get user agent
 * @return user agent
 */
function getUserAgent(): string {
  var userAgent = Util.getUserAgent(@userAgent);
  return userAgent;
}

/**
 * Get accesskey id by using credential
 * @return accesskey id
 */
async function getAccessKeyId(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var accessKeyId = @credential.getAccessKeyId();
  return accessKeyId;
}

/**
 * Get accesskey secret by using credential
 * @return accesskey secret
 */
async function getAccessKeySecret(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var secret = @credential.getAccessKeySecret();
  return secret;
}

/**
 * Get security token by using credential
 * @return security token
 */
async function getSecurityToken(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var token = @credential.getSecurityToken();
  return token;
}

/**
 * Get bearer token by credential
 * @return bearer token
 */
async function getBearerToken(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var token = @credential.getBearerToken();
  return token;
}

/**
 * Get credential type by credential
 * @return credential type e.g. access_key
 */
async function getType(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var authType = @credential.getType();
  return authType;
}

/**
 * If inputValue is not null, return it or return defaultValue
 * @param inputValue  users input value
 * @param defaultValue default value
 * @return the final result
 */
static function defaultAny(inputValue: any, defaultValue: any): any {
  if (Util.isUnset(inputValue)) {
    return defaultValue;
  }
  return inputValue;
}

/**
 * If the endpointRule and config.endpoint are empty, throw error
 * @param config config contains the necessary information to create a client
 */
function checkConfig(config: Config)throws : void {
  if (Util.empty(@endpointRule) && Util.empty(config.endpoint)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config.endpoint\' can not be empty'
    };
  }
}

/**
 * set gateway client
 * @param spi.
 */
function setGatewayClient(spi: SPI)throws : void {
  @spi = spi;
}

/**
 * set RPC header for debug
 * @param headers headers for debug, this header can be used only once.
 */
function setRpcHeaders(headers: map[string] string)throws : void {
  @headers = headers;
}

/**
 * get RPC header for debug
 */
function getRpcHeaders() throws : map[string] string {
  var headers: map[string] string = @headers;
  @headers = null;
  return headers;
}
