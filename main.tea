/**
 * This is for OpenApi SDK
 */

import Util;
import Credential;
import OpenApiUtil;
import SPI;
import XML;

type @endpoint = string
type @regionId = string
type @protocol = string
type @method = string
type @userAgent = string
type @endpointRule = string
type @endpointMap = map[string]string
type @suffix = string
type @readTimeout = integer
type @connectTimeout = integer
type @httpProxy = string
type @httpsProxy = string
type @socks5Proxy = string
type @socks5NetWork = string
type @noProxy = string
type @network = string
type @productId = string
type @maxIdleConns = integer
type @endpointType = string
type @openPlatformEndpoint = string
type @credential = Credential
type @signatureVersion = string
type @signatureAlgorithm = string
type @headers = map[string]string
type @spi = SPI
type @globalParameters = GlobalParameters
type @key = string
type @cert = string
type @ca = string
type @disableHttp2 = boolean

model GlobalParameters {
  headers?: map[string]string,
  queries?: map[string]string,
}
/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',example='a.txt',default=''),
  bearerToken?: string(description='bearer token',example='the-bearer-token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  method?: string(description='http method',example='GET',default=''),
  regionId?: string(description='region id',example='cn-hangzhou',default=''),
  readTimeout?: integer(description='read timeout',example='10',default=''),
  connectTimeout?: integer(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  credential?: Credential(description='credential',example='',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: integer(description='max idle conns',example='3',default=''),
  network?: string(description='network for endpoint',example='public',default=''),
  userAgent?: string(description='user agent',example='Alibabacloud/1',default=''),
  suffix?: string(description='suffix for endpoint',example='aliyun',default=''),
  socks5Proxy?: string(description='socks5 proxy',default=''),
  socks5NetWork?: string(description='socks5 network',example='TCP',default=''),
  endpointType?: string(description='endpoint type',example='internal',default=''),
  openPlatformEndpoint?: string(description='OpenPlatform endpoint',example='openplatform.aliyuncs.com',default=''),
  type?: string(description='credential type',example='access_key',default='',deprecated=true),
  signatureVersion?: string(description='Signature Version',example='v1',default=''),
  signatureAlgorithm?: string(description='Signature Algorithm',example='ACS3-HMAC-SHA256',default=''),
  globalParameters?: GlobalParameters(description='Global Parameters'),
  key?: string(description='privite key for client certificate', example='MIIEvQ',default=''),
  cert?: string(description='client certificate', example='-----BEGIN CERTIFICATE-----\nxxx-----END CERTIFICATE-----',default=''),
  ca?: string(description='server certificate', example='-----BEGIN CERTIFICATE-----\nxxx-----END CERTIFICATE-----',default=''),
  disableHttp2?: boolean(description='disable HTTP/2', example='false'),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  if(!Util.empty(config.accessKeyId) && !Util.empty(config.accessKeySecret)){
    if (!Util.empty(config.securityToken)) {
      config.type = 'sts';
    } else {
      config.type = 'access_key';
    }
    var credentialConfig = new Credential.Config{
      accessKeyId = config.accessKeyId,
      type = config.type,
      accessKeySecret = config.accessKeySecret
    };
    credentialConfig.securityToken = config.securityToken;
    @credential = new Credential(credentialConfig);
  } else if (!Util.empty(config.bearerToken)) {
    var cc = new Credential.Config{
      type = 'bearer',
      bearerToken = config.bearerToken
    };
    @credential = new Credential(cc);
  } else if(!Util.isUnset(config.credential)) {
    @credential = config.credential;
  }
  @endpoint = config.endpoint;
  @endpointType = config.endpointType;
  @network = config.network;
  @suffix = config.suffix;
  @protocol = config.protocol;
  @method = config.method;
  @regionId = config.regionId;
  @userAgent = config.userAgent;
  @readTimeout = config.readTimeout;
  @connectTimeout = config.connectTimeout;
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = config.maxIdleConns;
  @signatureVersion = config.signatureVersion;
  @signatureAlgorithm = config.signatureAlgorithm;
  @globalParameters = config.globalParameters;
  @key = config.key;
  @cert = config.cert;
  @ca = config.ca;
  @disableHttp2 = config.disableHttp2;
}

model OpenApiRequest {
  headers?: map[string]string,
  query?: map[string]string,
  body?: any,
  stream?: readable,
  hostMap?: map[string]string,
  endpointOverride?: string,
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRPCRequest(action: string, version: string, protocol: string, method: string, authType: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = '/';
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.query = {
    Action = action,
    Format = 'json',
    Version = version,
    Timestamp = OpenApiUtil.getTimestamp(),
    SignatureNonce = Util.getNonce(),
    ...globalQueries,
    ...extendsQueries,
    ...request.query
  };

  var headers = getRpcHeaders();
  if(Util.isUnset(headers)){
    // endpoint is setted in product client
    __request.headers = {
      host = @endpoint,
      x-acs-version = version,
      x-acs-action = action,
      user-agent = getUserAgent(),
      ...globalHeaders,
      ...extendsHeaders
    };
  } else {
    __request.headers = {
      host = @endpoint,
      x-acs-version = version,
      x-acs-action = action,
      user-agent = getUserAgent(),
      ...globalHeaders,
      ...extendsHeaders,
      ...headers
    };
  }

  if (!Util.isUnset(request.body)) {
    var m = Util.assertAsMap(request.body);
    var tmp = Util.anyifyMapValue(OpenApiUtil.query(m));
    __request.body = Util.toFormString(tmp);
    __request.headers.content-type = 'application/x-www-form-urlencoded';
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    var credentialModel = @credential.getCredential();
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.query.BearerToken = bearerToken;
      __request.query.SignatureType = 'BEARERTOKEN';
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.query.SecurityToken = securityToken;
      }
      __request.query.SignatureMethod = 'HMAC-SHA1';
      __request.query.SignatureVersion = '1.0';
      __request.query.AccessKeyId = accessKeyId;
      var t : map[string]any = null;
      if (!Util.isUnset(request.body)) {
        t = Util.assertAsMap(request.body);
      }
      var signedParam = {
        ...__request.query,
        ...OpenApiUtil.query(t)
      };
      __request.query.Signature = OpenApiUtil.getRPCSignature(signedParam, __request.method, accessKeySecret);
    }
  }
} returns {
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    var requestId = defaultAny(err.RequestId, err.requestId);
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${requestId}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param pathname pathname of every api
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doROARequest(action: string, version: string, protocol: string, method: string, authType: string, pathname: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.headers = {
    date = Util.getDateUTCString(),
    host = @endpoint,
    accept = 'application/json',
    x-acs-signature-nonce = Util.getNonce(),
    x-acs-signature-method = 'HMAC-SHA1',
    x-acs-signature-version = '1.0',
    x-acs-version = version,
    x-acs-action = action,
    user-agent = Util.getUserAgent(@userAgent),
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers
  };

  if (!Util.isUnset(request.body)) {
    __request.body = Util.toJSONString(request.body);
    __request.headers.content-type = 'application/json; charset=utf-8';
  }

  __request.query = {
    ...globalQueries,
    ...extendsQueries,
  };
  if (!Util.isUnset(request.query)) {
    __request.query = {
      ...__request.query,
      ...request.query
    };
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    var credentialModel = @credential.getCredential();
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      __request.headers.x-acs-signature-type = 'BEARERTOKEN';
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }

      var stringToSign = OpenApiUtil.getStringToSign(__request);
      __request.headers.authorization = `acs ${accessKeyId}:${OpenApiUtil.getROASignature(stringToSign, accessKeySecret)}`;
    }
  }
} returns {
  if (Util.equalNumber(__response.statusCode, 204)) {
    return {
      headers = __response.headers
    };
  }

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    var requestId = defaultAny(err.RequestId, err.requestId);
    requestId = defaultAny(requestId, err.requestid);
    err.statusCode = __response.statusCode;
     throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${requestId}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

/**
 * Encapsulate the request and invoke the network with form body
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param pathname pathname of every api
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doROARequestWithForm(action: string, version: string, protocol: string, method: string,  authType: string, pathname: string, bodyType: string, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.headers = {
    date = Util.getDateUTCString(),
    host = @endpoint,
    accept = 'application/json',
    x-acs-signature-nonce = Util.getNonce(),
    x-acs-signature-method = 'HMAC-SHA1',
    x-acs-signature-version = '1.0',
    x-acs-version = version,
    x-acs-action = action,
    user-agent = Util.getUserAgent(@userAgent),
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers
  };

  if (!Util.isUnset(request.body)) {
    var m = Util.assertAsMap(request.body);
    __request.body = OpenApiUtil.toForm(m);
    __request.headers.content-type = 'application/x-www-form-urlencoded';
  }


  __request.query = {
    ...globalQueries,
    ...extendsQueries,
  };
  if (!Util.isUnset(request.query)) {
    __request.query = {
      ...__request.query,
      ...request.query
    };
  }

  if (!Util.equalString(authType, 'Anonymous')) {
    var credentialModel = @credential.getCredential();
    var credentialType = credentialModel.type;
    if (Util.equalString(credentialType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      __request.headers.x-acs-signature-type = 'BEARERTOKEN';
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;
      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }

      var stringToSign = OpenApiUtil.getStringToSign(__request);
      __request.headers.authorization = `acs ${accessKeyId}:${OpenApiUtil.getROASignature(stringToSign, accessKeySecret)}`;
    }
  }
} returns {
  if (Util.equalNumber(__response.statusCode, 204)) {
    return {
      headers = __response.headers
    };
  }

  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var _res = Util.readAsJSON(__response.body);
    var err = Util.assertAsMap(_res);
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${defaultAny(err.RequestId, err.requestId)}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    return {
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

model Params = {
  action: string,
  version: string,
  protocol: string,
  pathname: string,
  method: string,
  authType: string,
  bodyType: string,
  reqBodyType: string,
  style?: string
}

async function callApi(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  if (Util.isUnset(params)) {
    throw {
      code = 'ParameterMissing',
      message = '\'params\' can not be unset'
    };
  }
  if (Util.isUnset(@signatureAlgorithm) || !Util.equalString(@signatureAlgorithm, 'v2')) {
    return doRequest(params, request, runtime);
  } else if (Util.equalString(params.style, 'ROA') && Util.equalString(params.reqBodyType, 'json')) {
    return doROARequest(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);
  } else if (Util.equalString(params.style, 'ROA')) {
    return doROARequestWithForm(params.action, params.version, params.protocol, params.method, params.authType, params.pathname, params.bodyType, request, runtime);
  } else {
    return doRPCRequest(params.action, params.version, params.protocol, params.method, params.authType, params.bodyType, request, runtime);
  }
}
/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, params.protocol);
  __request.method = params.method;
  __request.pathname = params.pathname;
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  __request.query = {
    ...globalQueries,
    ...extendsQueries,
    ...request.query,
  };

  // endpoint is setted in product client
  __request.headers = {
    host = @endpoint,
    x-acs-version = params.version,
    x-acs-action = params.action,
    user-agent = getUserAgent(),
    x-acs-date= OpenApiUtil.getTimestamp(),
    x-acs-signature-nonce = Util.getNonce(),
    accept = 'application/json',
    ...globalHeaders,
    ...extendsHeaders,
    ...request.headers,
  };
  if (Util.equalString(params.style, 'RPC')) {
    var headers = getRpcHeaders();
    if (!Util.isUnset(headers)) {
      __request.headers = {
        ...__request.headers,
        ...headers
      };
    }
  }

  var signatureAlgorithm = Util.defaultString(@signatureAlgorithm, 'ACS3-HMAC-SHA256');
  var hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(''), signatureAlgorithm));

  if (!Util.isUnset(request.stream)) {
    var tmp = Util.readAsBytes(request.stream);
    hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(tmp, signatureAlgorithm));
    __request.body = tmp;
    __request.headers.content-type = 'application/octet-stream';
  } else {
    if (!Util.isUnset(request.body)) {
      if (Util.equalString(params.reqBodyType, 'byte')) {
        var byteObj = Util.assertAsBytes(request.body);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(byteObj, signatureAlgorithm));
        __request.body = byteObj;
      } else if (Util.equalString(params.reqBodyType, 'json')) {
        var jsonObj = Util.toJSONString(request.body);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(jsonObj), signatureAlgorithm));
        __request.body = jsonObj;
        __request.headers.content-type = 'application/json; charset=utf-8';
      } else {
        var m = Util.assertAsMap(request.body);
        var formObj = OpenApiUtil.toForm(m);
        hashedRequestPayload = OpenApiUtil.hexEncode(OpenApiUtil.hash(Util.toBytes(formObj), signatureAlgorithm));
        __request.body = formObj;
        __request.headers.content-type = 'application/x-www-form-urlencoded';
      }
    }
  }

  __request.headers.x-acs-content-sha256 = hashedRequestPayload;

  if (!Util.equalString(params.authType, 'Anonymous')) {
    var credentialModel = @credential.getCredential();
    var authType = credentialModel.type;
    if (Util.equalString(authType, 'bearer')) {
      var bearerToken = credentialModel.bearerToken;
      __request.headers.x-acs-bearer-token = bearerToken;
      if (Util.equalString(params.style, 'RPC')) {
        __request.query.SignatureType = 'BEARERTOKEN';
      } else {
        __request.headers.x-acs-signature-type = 'BEARERTOKEN';
      }
      
    } else {
      var accessKeyId = credentialModel.accessKeyId;
      var accessKeySecret = credentialModel.accessKeySecret;
      var securityToken = credentialModel.securityToken;

      if (!Util.empty(securityToken)) {
        __request.headers.x-acs-accesskey-id = accessKeyId;
        __request.headers.x-acs-security-token = securityToken;
      }
      __request.headers.Authorization = OpenApiUtil.getAuthorization(__request, signatureAlgorithm, hashedRequestPayload, accessKeyId, accessKeySecret);
    }
  }
} returns {
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    var err : map[string]any = {};
    if (!Util.isUnset(__response.headers.content-type) && Util.equalString(__response.headers.content-type, 'text/xml;charset=utf-8')) {
      var _str = Util.readAsString(__response.body);
      var respMap = XML.parseXml(_str, null);
      err = Util.assertAsMap(respMap.Error);
    } else {
      var _res = Util.readAsJSON(__response.body);
      err = Util.assertAsMap(_res);
    }
    err.statusCode = __response.statusCode;
    throw {
      code = `${defaultAny(err.Code, err.code)}`,
      message = `code: ${__response.statusCode}, ${defaultAny(err.Message, err.message)} request id: ${defaultAny(err.RequestId, err.requestId)}`,
      data = err,
      description = `${defaultAny(err.Description, err.description)}`,
      accessDeniedDetail = defaultAny(err.AccessDeniedDetail, err.accessDeniedDetail),
    };
  }
  if (Util.equalString(params.bodyType, 'binary')) {
    var resp = {
      body = __response.body,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
    return resp;
  } else if (Util.equalString(params.bodyType, 'byte')) {
    var byt = Util.readAsBytes(__response.body);
    return {
      body = byt,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'string')) {
    var str = Util.readAsString(__response.body);
    return {
      body = str,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'json')){
    var obj = Util.readAsJSON(__response.body);
    var res = Util.assertAsMap(obj);
    return {
      body = res,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else if (Util.equalString(params.bodyType, 'array')){
    var arr = Util.readAsJSON(__response.body);
    return {
      body = arr,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  } else {
    var anything = Util.readAsString(__response.body);
    return {
      body = anything,
      headers = __response.headers,
      statusCode = __response.statusCode
    };
  }
} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}


/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param version product version
 * @param protocol http or https
 * @param method e.g. GET
 * @param authType authorization type e.g. AK
 * @param bodyType response body type e.g. String
 * @param request object of OpenApiRequest
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api execute(params: Params, request: OpenApiRequest, runtime: Util.RuntimeOptions): object {
  // spi = new Gateway();//Gateway implements SPI，这一步在产品 SDK 中实例化
  var headers = getRpcHeaders();
  var globalQueries : map[string]string = {};
  var globalHeaders : map[string]string = {};
  if (!Util.isUnset(@globalParameters)) {
    var globalParams = @globalParameters;
    if (!Util.isUnset(globalParams.queries)) {
      globalQueries = globalParams.queries;
    }
    if (!Util.isUnset(globalParams.headers)) {
      globalHeaders = globalParams.headers;
    }
  }
  var extendsHeaders : map[string]string = {};
  var extendsQueries : map[string]string = {};
  if (!Util.isUnset(runtime.extendsParameters)) {
    var extendsParameters = runtime.extendsParameters;
    if (!Util.isUnset(extendsParameters.headers)) {
      extendsHeaders = extendsParameters.headers;
    }
    if (!Util.isUnset(extendsParameters.queries)) {
      extendsQueries = extendsParameters.queries;
    }
  }
  var requestContext = new SPI.InterceptorContext.request{
    headers = {
      ...globalHeaders,
      ...extendsHeaders,
      ...request.headers,
      ...headers
    },
    query = {
      ...globalQueries,
      ...extendsQueries,
      ...request.query,
    },
    body = request.body,
    stream = request.stream,
    hostMap = request.hostMap,
    pathname = params.pathname,
    productId = @productId,
    action = params.action,
    version = params.version,
    protocol = Util.defaultString(@protocol, params.protocol),
    method = Util.defaultString(@method, params.method),
    authType = params.authType,
    bodyType = params.bodyType,
    reqBodyType = params.reqBodyType,
    style = params.style,
    credential = @credential,
    signatureVersion = @signatureVersion,
    signatureAlgorithm = @signatureAlgorithm,
    userAgent = getUserAgent()
  };
  var configurationContext = new SPI.InterceptorContext.configuration{
    regionId = @regionId,
    endpoint = Util.defaultString(request.endpointOverride, @endpoint),
    endpointRule = @endpointRule,
    endpointMap = @endpointMap,
    endpointType = @endpointType,
    network = @network,
    suffix = @suffix
  };
  var interceptorContext =  new SPI.InterceptorContext{
    request = requestContext,
    configuration = configurationContext
  };
  var attributeMap = new SPI.AttributeMap{};

  // 1. spi.modifyConfiguration(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyConfiguration(interceptorContext, attributeMap);

  // 2. spi.modifyRequest(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyRequest(interceptorContext, attributeMap);

  __request.protocol = interceptorContext.request.protocol;
  __request.method = interceptorContext.request.method;
  __request.pathname = interceptorContext.request.pathname;
  __request.query = interceptorContext.request.query;
  __request.body = interceptorContext.request.stream;
  __request.headers = interceptorContext.request.headers;
  
} returns {
  var responseContext = new SPI.InterceptorContext.response{
    statusCode = __response.statusCode,
    headers = __response.headers,
    body = __response.body
  };
  interceptorContext.response = responseContext;

  // 3. spi.modifyResponse(context: SPI.InterceptorContext, attributeMap: SPI.AttributeMap);
  @spi.modifyResponse(interceptorContext, attributeMap);

  return {
    headers = interceptorContext.response.headers,
    statusCode = interceptorContext.response.statusCode,
    body = interceptorContext.response.deserializedBody
  };

} runtime {
  timeouted = 'retry',
  key = Util.defaultString(runtime.key, @key),
  cert = Util.defaultString(runtime.cert, @cert),
  ca = Util.defaultString(runtime.ca, @ca),
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL,
  disableHttp2 = defaultAny(@disableHttp2, false)
}

/**
 * Get user agent
 * @return user agent
 */
function getUserAgent(): string {
  var userAgent = Util.getUserAgent(@userAgent);
  return userAgent;
}

/**
 * Get accesskey id by using credential
 * @return accesskey id
 */
async function getAccessKeyId(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var accessKeyId = @credential.getAccessKeyId();
  return accessKeyId;
}

/**
 * Get accesskey secret by using credential
 * @return accesskey secret
 */
async function getAccessKeySecret(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var secret = @credential.getAccessKeySecret();
  return secret;
}

/**
 * Get security token by using credential
 * @return security token
 */
async function getSecurityToken(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var token = @credential.getSecurityToken();
  return token;
}

/**
 * Get bearer token by credential
 * @return bearer token
 */
async function getBearerToken(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var token = @credential.getBearerToken();
  return token;
}

/**
 * Get credential type by credential
 * @return credential type e.g. access_key
 */
async function getType(): string {
  if (Util.isUnset(@credential)) {
    return '';
  }
  var authType = @credential.getType();
  return authType;
}

/**
 * If inputValue is not null, return it or return defaultValue
 * @param inputValue  users input value
 * @param defaultValue default value
 * @return the final result
 */
static function defaultAny(inputValue: any, defaultValue: any): any {
  if (Util.isUnset(inputValue)) {
    return defaultValue;
  }
  return inputValue;
}

/**
 * If the endpointRule and config.endpoint are empty, throw error
 * @param config config contains the necessary information to create a client
 */
function checkConfig(config: Config)throws : void {
  if (Util.empty(@endpointRule) && Util.empty(config.endpoint)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config.endpoint\' can not be empty'
    };
  }
}

/**
 * set gateway client
 * @param spi.
 */
function setGatewayClient(spi: SPI)throws : void {
  @spi = spi;
}

/**
 * set RPC header for debug
 * @param headers headers for debug, this header can be used only once.
 */
function setRpcHeaders(headers: map[string] string)throws : void {
  @headers = headers;
}

/**
 * get RPC header for debug
 */
function getRpcHeaders() throws : map[string] string {
  var headers: map[string] string = @headers;
  @headers = null;
  return headers;
}
